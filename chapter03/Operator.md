Operator (연산자)
=========================

연산자와 피연산자
---------
*****

* 연산자 : 연산을 수행하는 기호(+-*/)
* 피연산자 : 연산자의 연산 수행 대상  
=> 모든 연산자는 연산결과를 반환한다.  

y = 4 * x + 3; //x의 값이 5라면, y의 값은 23이 된다.


연산자의 종류
--------
*****

* 산술연산자 : 사직 연산과 나머지 연산(%)
: + - * / %
 
* 비교연산자 : 크고 작음과 같고 다름을ㅇ 비교
: < > >= <= == !=

* 논리연산자 : '그리고(AND)'와 '또는(OR)'으로 조건을 연결
: && || !

* 대입연산자 : 우변의 값을 좌변에 저장
: =

* 기타 : 형변환 연산자, 삼항 연산자, instanceof연산자
: (type) ?: instanceof


연산자의 우선순위
----------
*****
  
"하나의 식(expression)에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것"  
 
1. 단항연산자 ++ -- + - ~ ! (type)
2. 산술연산자 * / % + - << >>
3. 비교연산자 < > <= >= instanceof == !=
4. 논리연산자 & ^ | && || 
5. 삼항연산자 ?:
6. 대입연산자 = += -= *= /= &= <<= >>= &= ^= |=  

"상식적으로 생각하면 된다."


연산자의 결합규칙
-----------
*****

"우선순위가 같은 연산자가 있을 때, 어떤거 먼저? => 대입과 단한 연산자를 제외하면 모두 왼쪽->오른쪽"
1. 산술>비교>논리>대입, 대입은 제일 마지막에 수행된다.
2. 단항(1)>이상(2)>삼항(3), 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향을 왼쪽에서 오른쪽이다.


증감연산자
-------------
*****

* 증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
* 감소 연산자(--) : 피연산자의 값을 1 감소시킨다.  
<br>
* 전위형 : 값이 참조되기 전에 증가시킨다. : j = ++i;
* 후위형 : 값이 참도된 후에 증가시킨다.  : j = i++;  
=> "증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다."   
<br>
ex) j = ++i; // 전위형  
=> ++i; j = i; //증가 후에 참조하여 대입  
  ex) j = i++; // 후위형  
  => j = i; i++; //참조하여 대입 후에 증가



부호연산자
-------------
*****

* '-'는 피연산자의 부호를 반대로 변경 (단항연산자)  
ex)  
int i = -10;  
i = -1;  
System.out.println(i); //10  


형변환연산자
-------------
*****

* 형변환이란?
: 변수 또는 상수의 타입을 다른 타입으로 변환하는 것  
"(타입)피연산자"

double d = 85.4;  
int score = (int)d;  
int score = (int)85.4;  
int score = 85;  
  
char 유니코드로 정수변환 가능  
실수에서 정수 변환시 반올림되지않는다.

* int -> char 
: (char)65 -> 'A'  

* char -> int
: (int)'A' -> 64

* float -> int
: (int)1.6f -> 1

* int -> float
: (float)10 -> 10.0f


자동형변환 
------------------
*****

"기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다."  
작은타입에서 -> 큰타입으로  
byte -> short -> int -> long -> float -> double  
char -> int

long(8byte) -> float(4byte) float가 작지만 실제표현할수있는 값의 범위는 실수형이 크기때문에 가능하다.

float f = 1234;  //int타입의 값을 float타입의 변수에 저장  
int i = 3.14f;   //error -> float보다 int가 저 작기때문에 값 손실 발생이 일어날 수 있어 자동형변환이안된다.  
int i = (int)3.14f;  //가능  


byte b = 10;  
int i = b;  //자동형변환 가능  
int i2 = 300;  
byte b2 = (byte)i2;  //자동형변환 불가로 (타입)으로 수동형변환  
<br>  

byte b = 100;  //ok  100=리터럴=상수
int i = 100;  
byte b = i;  //에러  i=변수
byte b = (byte)i;  //ok. 수동형변환 필요  
  
byte b = 1000;  //에러. byte타입의 범위(-128~127)  
byte b  = (byte)1000;  //ok. 그러나 값 손실이 발생해서 변수 b에는 -24가 저장됨.