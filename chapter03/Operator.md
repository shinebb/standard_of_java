Operator (연산자)
=========================

연산자와 피연산자
---------
*****

* 연산자 : 연산을 수행하는 기호(+-*/)
* 피연산자 : 연산자의 연산 수행 대상  
=> 모든 연산자는 연산결과를 반환한다.  

y = 4 * x + 3; //x의 값이 5라면, y의 값은 23이 된다.


연산자의 종류
--------
*****

* 산술연산자 : 사직 연산과 나머지 연산(%)
: + - * / %
 
* 비교연산자 : 크고 작음과 같고 다름을ㅇ 비교
: < > >= <= == !=

* 논리연산자 : '그리고(AND)'와 '또는(OR)'으로 조건을 연결
: && || !

* 대입연산자 : 우변의 값을 좌변에 저장
: =

* 기타 : 형변환 연산자, 삼항 연산자, instanceof연산자
: (type) ?: instanceof


연산자의 우선순위
----------
*****
  
"하나의 식(expression)에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것"  
 
1. 단항연산자 ++ -- + - ~ ! (type)
2. 산술연산자 * / % + - << >>
3. 비교연산자 < > <= >= instanceof == !=
4. 논리연산자 & ^ | && || 
5. 삼항연산자 ?:
6. 대입연산자 = += -= *= /= &= <<= >>= &= ^= |=  

"상식적으로 생각하면 된다."


연산자의 결합규칙
-----------
*****

"우선순위가 같은 연산자가 있을 때, 어떤거 먼저? => 대입과 단한 연산자를 제외하면 모두 왼쪽->오른쪽"
1. 산술>비교>논리>대입, 대입은 제일 마지막에 수행된다.
2. 단항(1)>이상(2)>삼항(3), 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향을 왼쪽에서 오른쪽이다.


증감연산자
-------------
*****

* 증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
* 감소 연산자(--) : 피연산자의 값을 1 감소시킨다.  
<br>
* 전위형 : 값이 참조되기 전에 증가시킨다. : j = ++i;
* 후위형 : 값이 참도된 후에 증가시킨다.  : j = i++;  
=> "증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다."   
<br>
ex) j = ++i; // 전위형  
=> ++i; j = i; //증가 후에 참조하여 대입  
  ex) j = i++; // 후위형  
  => j = i; i++; //참조하여 대입 후에 증가



부호연산자
-------------
*****

* '-'는 피연산자의 부호를 반대로 변경 (단항연산자)  
ex)  
int i = -10;  
i = -1;  
System.out.println(i); //10  


형변환연산자
-------------
*****

* 형변환이란?
: 변수 또는 상수의 타입을 다른 타입으로 변환하는 것  
"(타입)피연산자"

double d = 85.4;  
int score = (int)d;  
int score = (int)85.4;  
int score = 85;  
  
char 유니코드로 정수변환 가능  
실수에서 정수 변환시 반올림되지않는다.

* int -> char 
: (char)65 -> 'A'  

* char -> int
: (int)'A' -> 64

* float -> int
: (int)1.6f -> 1

* int -> float
: (float)10 -> 10.0f


자동형변환 
------------------
*****

"기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다."  
작은타입에서 -> 큰타입으로  
byte -> short -> int -> long -> float -> double  
char -> int

long(8byte) -> float(4byte) float가 작지만 실제표현할수있는 값의 범위는 실수형이 크기때문에 가능하다.

float f = 1234;  //int타입의 값을 float타입의 변수에 저장  
int i = 3.14f;   //error -> float보다 int가 저 작기때문에 값 손실 발생이 일어날 수 있어 자동형변환이안된다.  
int i = (int)3.14f;  //가능  


byte b = 10;  
int i = b;  //자동형변환 가능  
int i2 = 300;  
byte b2 = (byte)i2;  //자동형변환 불가로 (타입)으로 수동형변환  
<br>  

byte b = 100;  //ok  100=리터럴=상수
int i = 100;  
byte b = i;  //에러  i=변수
byte b = (byte)i;  //ok. 수동형변환 필요  
  
byte b = 1000;  //에러. byte타입의 범위(-128~127)  
byte b  = (byte)1000;  //ok. 그러나 값 손실이 발생해서 변수 b에는 -24가 저장됨.  
  

산술변환
------------
*****

"연산 전에 피연산자의 타입을 일치시키는 것"  
1. 두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치 : 값손실을 최소화하기 위해)  
long + int -> long + long -> long  
float + int -> float + float -> float  
double + float -> double + double -> double  
<br>  

2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.  
byte + short -> int + int -> int  
char + short -> int + int -> int    
ex) char 2 - char 0 -> int 50(유니코드) -> int 48(유니코드) -> 2 



나머지 연산자
-----------
*****
"오른쪽 피연산자로 나누고 남은 나머지를 반환"

int x = 10;  
int y = 8;

10 / 1 = 1 (몫)  
10 % 8 = 2 (나머지)  
10 % -8 = 2 (부호는 무시된다.)



비교연산자
----------
*****

"두 피연산자를 비교해서 true(참) 또는 false()거짓을 반환"  
'A'>'B' => 65>66 => false  
  
* 문자열의 비교
: 문자열 비교에는 == 대신 equals()를 사용해야 한다.  

String str1 = "abc";  
String str2 = "abc";  

System.out.println(str1==str2);   //true   
System.out.println(str1.equals(str2)); //true  

String str1 = new String("abc");  
String str2 = new String("abc");  

System.out.println(str1==str2);   //false  
System.out.println(str1.equals(str2)); //true    
  
* 참고    
: str.equalsIgnoreCase("yes") : 문자열 str의 내용이 "yes"일 때(대소문자 구문안함)


논리연산자
----------
*****
"조건식을 연결할 때 사용하는 연산자"  
||(OR)  
&&(AND)  

x는 10보다 크고 20보다 작다  
x>10 && x<20  
10<x && x<20  
10<x<20 -> 불가능  
  
i는 2의 배수 또는 3의 배수이다.  
i%2==0 || i%3==0  

i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.  
(i%2==0 || i%3==0) && i%6!=0  

문자 ch는 숫자('0'~'9')이다.  
'0'<=ch && ch<='9'  
ch = '5'일 때  
48<=53 && 53<=57  

문자 ch는 대문자 또는 소문자이다.  
('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')  
=>유니코드는 연속되는 숫자로 이루어져있기때문에 해당식이 가능하다.


논리 부정 연산자
-------------
*****

"true를 false로, false는 true 바꾼다."    
문자 ch가 소문자가 아니다.  
ch<'a' || ch>'z'    
=> !('a'<=ch && ch<='z')  
=> 더 가독성 있게 표현할 수 있다.  


조건 연산자 ?:
--------------
*****
"조건식의 결과에 따란 연산결과를 달리한다."  
* 조건식 ? 식1(참일때) : 식2(거짓일때)

result = (x>y) ? x : y;  //괄호 생략 가능  
(x>y)가 참이면 x, 거짓이면 y  


대입 연산자
-------------
*****
"오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환"  
"모든 연산자는 결과값을 반환"  

lvalue : 대입 연산자의 왼쪽 피연산자 -> lvalue는 저장공간(변수,배열)이어야 한다.  
rvalue : 대입 연산자의 오른쪽 피연산자  

 
복합 대입 연산자
--------------
*****
"대입 연산자와 다른 연산자를 하나로 축약"  

i += 3; => i = i+3;






